# apt-get update 和 apt-get upgrade 的区别

**总的来说，apt-get update就是访问服务器，更新可获取软件及其版本信息，但仅仅给出一个可更新的list，具体更新需要通过apt-get upgrade，apt-get upgrade可将软件进行更新，但是有文章指出不建议一次性全部更新，因为最新的不一定是最好的，有可能出现版本不兼容的情况。**

入门linux的同志，刚开始最迫切想知道的，大概一个是中文输入法，另一个就是怎么安装软件。本文主要讲一下LINUX安装软件方面的特点。

在windows下安装软件，我们只需要有EXE文件，然后双击，下一步直接OK就可以了。但在LINUX下，不是这样的。每个LINUX的发行版，比如UBUNTU，都会维护一个自己的软件仓库，我们常用的几乎所有软件都在这里面。这里面的软件绝对安全，而且绝对的能正常安装。

那我们要怎么安装呢？在UBUNTU下，我们维护一个源列表，源列表里面都是一些网址信息，这每一条网址就是一个源，这个地址指向的数据标识着这台源服务器上有哪些软件可以安装使用。

编辑源命令：

**sudo gedit /etc/apt/sources.list**

在这个文件里加入或者注释（加#）掉一些源后，保存。这时候，我们的源列表里指向的软件就会增加或减少一部分。

接一下要做的就是：

**sudo apt-get update**

这个命令，会访问源列表里的每个网址，并读取软件列表，然后保存在本地电脑。我们在新立得软件包管理器里看到的软件列表，都是通过update命令更新的。

update后，可能需要upgrade一下。

**sudo apt-get upgrade**

这个命令，会把本地已安装的软件，与刚下载的软件列表里对应软件进行对比，如果发现已安装的软件版本太低，就会提示你更新。如果你的软件都是最新版本，会提示：

**升级了0个软件包，新安装了0个软件包，要卸载0个软件包，有0个软件包未被升级。**

总而言之，update是更新软件列表，upgrade是更新软件。

#　文件 .d 和 直接加d 的区别

```python
# .d 代表文件夹 dir 说明他有很多一类的配置文件都在 .d 文件夹里 比如：
# nginx 里面有一个conf.d 它里面就是各个站点的配置文件

# 文件（一般是bin下）最后直接带d 代表 守护进程Daemons 如：
# mysqld 代表mysql的守护进程
```

# [/etc/rc.local 与 /etc/init.d Linux 开机自动运行程序](https://www.cnblogs.com/fatt/p/4790561.html)

```
1. /etc/rc.local    
这是使用者自订开机启动程序,把需要开机自动运行的程序写在这个脚本里，在完成 run level 3 的服务启动后，如果我还有其他的动作想要完成时，举例来说， 我还想要寄一封 mail 给某个系统管理帐号，通知他，系统刚刚重新开机完毕，那么， 是否应该要制作一个 shell script 放置在 /etc/rc.d/init.d/ 里面，然后再以连结方式连结到 /etc/rc.d/rc3.d/ 里面呢？呵呵！当然不需要！还记得上一小节提到的 /etc/rc.d/rc.local 吧？ 这个档案就可以执行您自己想要执行的系统指令了。像不像早期 DOS 年代的 autoexec.bat 与 config.sys 呢？ ^_^  也就是说，我有任何想要在开机时就进行的工作时，直接将他写入 /etc/rc.local ， 那么该工作就会在开机的时候自动被载入喔！而不必等我们登入系统去启动呢！ 是否很方便啊！一般来说，鸟哥就很喜欢把自己制作的 shell script 完整档名写入 /etc/rc.d/rc.local ，如此一来，开机就会将我的 shell script 执行过，真是好棒那！  也就是说，在linux启动的最后阶段，系统会执行存于rc.local中的命令。和windows里面的“启动”菜单有点像，但是设置麻烦些，功能更强大使用情况：
```

1）oracle等服务器的启动：如果你需要你的oracle可以随着系统一起启动，你可以去看看/etc/oratab这个文件，然后去了解它，你就会发现这里才是它正确的位置所在

2）静态路由： 对于需要增加大量的不是本网段的路由时，很多人喜欢在/etc/rc.d/rc.local里添加类似

route add -net 192.168.1.0 netmask 255.255.255.0 gw 10.224.0.251

route add -host 192.168.100.1  gw 10.224.0.251

 

\2. /etc/init.d 
    这个目录存放的是一些脚本，一般是linux以rpm包安装时设定的一些服务的启动脚本。系统在安装时装了好多rpm包，这里面就有很多对应的脚本。执行这些脚本可以用来启动，停止，重启这些服务。举个例子来说，如果你要重新启动 sendmail 的话，而且你的 sendmail 是以 rpm 来安装的，那么下达 /etc/rc.d/init.d/sendmail restart 就可以直接启动 sendmail 啰！
    前面说到，/etc/rc.d/init.d这个目录下的脚本就类似与windows中的注册表，在系统启动的时候执行。程序运行到这里(init进程读取了运行级别)， 是该运行init.d里的脚本了，但是并不是直接运行，而是有选择的因为系统并不需要启动所有的服务。
　　那么，系统是如何选择哪些需要启动哪些不要呢？这时刚才说的运行级别就起作用了。在决定了系统启动的run level之后，/etc/rc.d/rc这个脚本先执行。在RH9和FC7的源码中它都是一上来就check_runlevel()（虽然实现的代码不一样，也大同小异），知道了运行级别之后，对于每一个运行级别，在rc.d下都有一个子目录分别是rc0.d，rc1.d ….. rc6.d。每个目录下都是到init.d目录的一部分脚本一些链接。每个级别要执行哪些服务就在相对应的目录下，比如级别5要启动的服务就都放在rc5.d下，但是放在这个rc5.d下的都是一些链接文件，链接到init.d中相对应的文件，真正干活到init.d里的脚本。

 

  以下内容是作者自己的翻译版本，如需转载到CSDN外其他网站，请注明本文链接。

 **一、关于/etc/init.d**

   如果你使用过linux系统，那么你一定听说过init.d目录。这个目录到底是干嘛的呢？它归根结底只做了一件事情，但这件事情非同小可，是为整个系统做的，因此它非常重要。init.d目录包含许多系统各种服务的启动和停止脚本。它控制着所有从acpid到x11-common的各种事务。当然，init.d远远没有这么简单。（译者注：acpid 是linux操作系统新型电源管理标准 ；X11也叫做X Window系统，X Window系统 (X11或X)是一种位图显示的 视窗系统 。它是在 Unix 和 类Unix [操作系统](http://baike.baidu.com/view/880.htm) ，以及 OpenVMS 上建立[图形用户界面](http://baike.baidu.com/view/185360.htm) 的标准工具包和协议，并可用于几乎已有的[现代操作系统](http://baike.baidu.com/view/2563933.htm)）。

  当你查看/etc目录时，你会发现许多***rc#.d*** 形式存在的目录（这里#代表一个指定的初始化级别，范围是0~6）。在这些目录之下，包含了许多对进程进行控制的脚本。这些脚本要么以"K"开头，要么以"S"开头。以K开头的脚本运行在以S开头的脚本之前。这些脚本放置的地方，将决定这些脚本什么时候开始运行。在这些目录之间，系统服务一起合作，就像运行状况良好的机器一样。然而，有时候你希望能在不使用kill 或killall 命令的情况下，能干净的启动或杀死一个进程。这就是/etc/init.d能够派上用场的地方了！

  如果你在使用Fedora系统，你可以找到这个目录：**/etc/rc.d/init.d。实际上无论init.d放在什么地方，它都发挥着相同的作用。**

   **为了能够使用init.d目录下的脚本，你需要有root权限或sudo权限。每个脚本都将被作为一个命令运行，该命令的结构大致如下所示：**

   */etc/init.d/command 选项*

   comand是实际运行的命令，选项可以有如下几种：

- start
- stop
- reload
- restart
- force-reload

​    大多数的情况下，你会使用start,stop,restart选项。例如，如果你想关闭网络，你可以使用如下形式的命令：

   

​     */etc/init.d/networking stop*

​    又比如，你改变了网络设置，并且需要重启网络。你可以使用如下命令：

​    */etc/init.d/networking restart*

​    init.d目录下常用初始化脚本有：

​    

- networking
- samba
- apache2
- ftpd
- sshd
- dovecot
- mysql

​     当然，你可能有其他更多常用的脚本，这个取决于你安装了什么linux操作系统。

 **二、关于/etc/rc.local**

   rc.local也是我经常使用的一个脚本。该脚本是在系统初始化级别脚本运行之后再执行的，因此可以安全地在里面添加你想在系统启动之后执行的脚本。常见的情况是你可以再里面添加nfs挂载/mount脚本。此外，你也可以在里面添加一些调试用的脚本命令。例如，我就碰到过这种情况：samba服务总是无法正常运行，而检查发现，samba是在系统启动过程中就该启动执行的，也就是说，samba守护程序配置保证了这种功能本应该正确执行。碰到这种类似情况，一般我也懒得花大量时间去查为什么，我只需要简单的在/etc/rc.local脚本里加上这么一行：

​     */etc/init.d/samba start*

   这样就成功的解决了samba服务异常的问题。