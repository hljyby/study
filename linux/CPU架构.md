# cpu架构

## 两种指令集

- CISC 复杂指令集计算机
- RISC 精简指令集计算机
  Arm与x86 基础概念

## 四大CPU体系

ARM/MIPS/PowerPC均是基于精简指令集机器处理器的架构；X86则是基于复杂指令集的架构，Atom是x86或者是x86指令集的精简版

### 1.ARM

ARM架构，过去称作进阶精简指令集机器（Advanced RISC Machine，更早称作：Acorn RISC Machine），是一个32位精简指令集（RISC）处理器架构，其广泛地使用在许多嵌入式系统设计。由于节能的特点，ARM处理器非常适用于行动通讯领域，符合其主要设计目标为低耗电的特性。

### 2.x86系列/Atom(安腾)

IA 是Intel Architecture(英特尔体系架构)的简称，有IA-32和IA-64，均属于X86体系结构。

x86或80x86是英代尔Intel首先开发制造的一种微处理器体系结构的泛称。x86架构是重要地可变指令长度的CISC（复杂指令集电脑，Complex Instruction Set Computer）。

Intel Atom（中文：凌动，开发代号：Silverthorne）是Intel的一个超低电压处理器系列。处理器采用45纳米工艺制造，集成4700万个晶体管。L2缓存为512KB，支持SSE3指令集，和VT虚拟化技术（部份型号）。

### 3.MIPS系列

MIPS是世界上很流行的一种RISC处理器。MIPS的意思是“无内部互锁流水级的微处理器”(Microprocessor without interlockedpipedstages)，其机制是尽量利用软件办法避免流水线中的数据相关问题。它最早是在80年代初期由斯坦福(Stanford)大学Hennessy教授领导的研究小组研制出来的。MIPS公司的R系列就是在此基础上开发的RISC工业产品的微处理器。这些系列产品为很多计算机公司采用构成各种工作站和计算机系统。

MIPS技术公司是美国著名的芯片设计公司，它采用精简指令系统计算结构(RISC)来设计芯片。和英特尔采用的复杂指令系统计算结构(CISC)相比，RISC具有设计更简单、设计周期更短等优点，并可以应用更多先进的技术，开发更快的下一代处理器。MIPS是出现最早的商业RISC架构芯片之一，新的架构集成了所有原来MIPS指令集，并增加了许多更强大的功能。MIPS自己只进行CPU的设计，之后把设计方案授权给客户，使得客户能够制造出高性能的CPU。

### 4.PowerPC系列

PowerPC 是一种精简指令集（RISC）架构的中央处理器（CPU），其基本的设计源自IBM（国际商用机器公司）的IBM PowerPC 601 微处理器POWER（Performance Optimized With Enhanced RISC；《IBM Connect 电子报》2007年8月号译为“增强RISC性能优化”）架构。二十世纪九十年代，IBM(国际商用机器公司)、Apple（苹果公司）和Motorola（摩托罗拉）公司开发PowerPC芯片成功，并制造出基于PowerPC的多处理器计算机。PowerPC架构的特点是可伸缩性好、方便灵活。

## x86与ARM区别（冯诺依曼和arm）

[original](https://www.cnblogs.com/crazyValen/archive/2016/04/13/5389316.html)
现代的CPU基本上归为冯洛伊曼结构（也成普林斯顿结构）和哈佛结构。冯洛伊曼结构就是我们所说的X86架构，而哈佛结构就是ARM架构。一个广泛用于桌面端（台式/笔记本/服务器/工作站等），一个雄踞移动领域，我们的手持设备（平板\手机用的大多就是他了）。
他们的如区别如下：
一、冯洛伊曼的体系核心是：数据和指令混在一起，统一编址。区分哪些是指令和哪些是数据大致上有以下方法：
　　1、用寄存器和指令周期来区分数据和指令。例如：CS段（codesegment代码段）和DS段（datasegment数据段），前者CPU是认为存放的都是指令，后者CPU认为存放的都是数据；
　　2、通过不同的时间段来区分指令和数据，在取指阶段取出的就是指令，执行阶段取出的就是数据。这个都很好理解吧。
二、哈佛架构的核心是：数据和指令是区分开的。独立编址，就算地址一样，数据也是不一样的。
![在这里插入图片描述](G:\新知识\linux\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbnhpYW9kZXJlbg==,size_16,color_FFFFFF,t_70)
再来讨论下两个架构的效率区别
经过上面的描述，各位已经知道这两个架构的主要区别了。
CPU大致工作如下：取指令、指令译码和执行指令。
指令1至指令3均为存、取数指令，对冯诺伊曼结构处理器，由于取指令和存取数据要从同一个存储空间存取，经由同一总线传输，因而它们无法重叠执行，只有一个完成后再进行下一个。如下图所示：
![在这里插入图片描述](G:\新知识\linux\images\1watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbnhpYW9kZXJlbg==,size_16,color_FFFFFF,t_70)

采用哈佛结构，由于取指令和存取数据分别经由不同的存储空间和不同的总线，使得各条指令可以重叠执行，这样，也就克服了数据流传输的瓶颈，提高了运算速度。 哈佛结构强调了总的系统速度以及通讯和处理器配置方面的灵活性。
下面是对上图的几个引申知识点：
时钟周期也称为振荡周期：CPU无非就是开关闭合电路组成，定义为时钟脉冲的倒数。是计算机中的最基本的、最小的时间单位。 在一个时钟周期内，CPU仅完成一个最基本的动作。时钟脉冲是计算机的基本工作脉冲，控制着计算机的工作节奏。时钟频率越高，工作速度就越快。
机器周期：常把一条指令的执行过程划分为若干个阶段，每一个阶段完成一项工作。每一项工作称为一个基本操作，完成一个基本操作所需要的时间称为机器周期。
指令周期：执行一条指令所需要的时间，一般由若干个机器周期组成。指令不同，所需的机器周期也不同。
关系：指令周期通常用若干个机器周期表示，而机器周期时间又包含有若干个时钟周期。

# ARM与X86 CPU架构区别

[ARM与X86 CPU架构区别](https://www.cnblogs.com/CZM-/p/9611312.html)


CISC(复杂指令集计算机)和RISC(精简指令集计算机)是当前CPU的两种架构。它们的区别在于不同的CPU设计理念和方法。早期的CPU全部是CISC架构，它的设计目的是 CISC要用最少的机器语言指令来完成所需的计算任务。

 

RISC和CISC是设计制造微处理器的两种典型技术，虽然它们都是试图在体系结构、操作运行、软件硬件、编译时间和运行时间等诸多因素中做出某种平衡，以求达到高效的目的，但采用的方法不同，因此，在很多方面差异很大。

x86架构采用CISC，而ARM采用RISC。 

ARM成立于1991年，是一家出售IP（技术知识产权）的公司，所谓的技术知识产权，有点像卖房屋的结构设计图，至于要怎么修改，哪边开窗户，以及要怎么添加其它的花园，则由买了设计图的厂商自己决定。 

而ARM的架构是采用RISC架构，如同它的名称一样，Advanced RISC Machines，RISC架构在当初的PC架构争霸战虽然败给Intel所主导的x86处理器架构，却默默在另外的领域成长壮大；小到硬盘转速控制、电信基地台的计算、汽车喷射引擎的控制、音响系统、相机引擎，大到电动机具的控制等等，都能够看见采用ARM授权架构处理器的身影。 

而有了设计图，当然还要有把设计图实现的厂商，而这些就是ARM架构的授权客户群。包括： 

TI OMAP、Qualcomm Snapdragon、三星的蜂鸟（Hummingbird）、猎户座（Orion）、飞思卡尔（Freescale）的i.MX，或是ST-Ericsson的应用处理器、Freescale、联发科、Telechip、新岸线等。 

X86是英特尔Intel首先开发制造的一种微处理器体系结构的泛称，包括Intel8086、80186、80286、80386以及80486以86结尾系列，英特尔统治整个CPU产业链长达数十年。但是，Intel以增加处理器本身复杂度作为代价，去换取更高的性能，但集成的指令集数量越来越多，给硬件带来的负荷也就越来越大，无形中增加了功耗和设计难度。 

ARM（Advanced RISC Machines）公司是苹果、Acorn、VLSI、Technology等公司的合资企业。ARM采用将芯片的设计方案授权（licensing）给其他公司生产的模式，在世界范围结成了超过100个的合作伙伴（Partners），将封闭设计的Intel公司变成全民公敌。

 

ARM处理器非常适用于移动通信领域，具有低成本、高性能和低耗电的特性，ARM的高性价比和低耗能在移动市场比英特尔更具优势。 

ARM的架构相较于x86有哪些特点？相较于基于CISC的x86架构处理器，由于为了满足电脑产业发展而不断加入指令集，使得处理器日益庞大，但每个指令集用到的频率也越差越大，许多指令到后来已经相当少用，甚至是可以被新的指令所取代。

 

而ARM架构则大幅简化架构，仅保留所需要的指令，可以让整个处理器更为简化，拥有小体积、高效能的特性。 

另外，ARM的架构老早就已经做到高密度整合，由于ARM授权的弹性以及核心架构的单纯，ARM处理器架构可以很容易与其它专职的特殊核心，像GPU、多媒体译码核心、基频调制解调器、I/O控制等架构整合，透过SoC（System On a Chip，系统单芯片）的方式，一颗小小的ARM架构应用处理器，完成近年x86架构处理器积极跨足的单芯片设计，并且通过各种不同的核心分工各司其职。

 

ARM架构应用处理器的核心负担相较传统x86处理器低了许多，并且因为早前应用处理器的需求就是以低功耗为重点，即便如今效能不断提升，仍是以保有省电的特性为前提发展条件。 

ARM架构的另一个优点是自由性，只要向ARM买下核心授权，就可以与其它IP公司的方案以及这家授权客户本身的优势技术整合，虽同为同一世代的ARM核心架构，即便频率相同，结果也不同。

 

不过这也使得ARM应用处理器光从基本规格不一定能看出其操作效能，例如同样隶属高通Snapdragon，频率1GHz的第一世代旗舰QSD8x50甚至不敌频率仅800MHz的第二世代MSM7230。 

 

 

ARM的架构之所以能够在智能手机以及平板领域迅速窜红，苹果iOS可说是大功臣，在苹果之前，智能手机在市场上一直载浮载沉，虽然有着号称智能手机平台市占率第一的Nokia Symbian，以及Windows Mobile、Palm OS、BlackBerry等系统，不过当时的环境缺乏移动网络为后盾，在线商店的概念还未发展成型；

 

一直到苹果以iPhone打响新世代智能手机第一炮后，市场才真正体会到智能手机原来可以是这么容易使用。 

iPhone的出现也间接带起市场对于ARM架构应用处理器的需求，不过光是苹果也无法带起市场对于ARM处理器的需求，还有WM（WP7)手机与Symbian也纷纷加入新一代智能手机战局。

 

但是真正成为关键的是Google

Android宣布参战后，其它手机厂商取得一个相较过去成熟的通用智能手机平台，而各厂商又为了进行产品差异化，开始针对ARM架构应用处理器的效能以及硬件支持要求，使得过去发展缓慢的ARM架构一下子热络起来，也让ARM一夕之间成为火热话题。 

![img](G:\新知识\linux\images\840517-20180909003539414-1801249029.png)

 

 

 

GOOGLE的Android系统和苹果的IPAD、IPHONE推出后，ARM架构的电脑系统（特别是在终端方面应用）受到用户的广泛支持和追捧，ARM+Android成为IT、通信领域最热门的话题，众多芯片厂商纷纷推出具有各种独特应用功能基于ARM结构开发的产品，近期最新形成的“异构概念”更成为电脑今后发展主要方向。

 

在IT行业推崇了20多年的“性价比“概念受到根本的动摇和冲击，“适用的才是最好的”已经被越来越多的用户接受。 

我们就ARM架构的系统与X86架构系统的特性进行一个系统分析，方便用户在选择系统时进行理性、合理的比价分析。 


一、性能： 

X86结构的电脑无论如何都比ARM结构的系统在性能方面要快得多、强得多。X86的CPU随便就是1G以上、双核、四核大行其道，通常使用45nm（甚至更高级）制程的工艺进行生产；而ARM方面：CPU通常是几百兆，这几年才出现1G左右的CPU，制程通常使用不到65nm制程的工艺，可以说在性能和生产工艺方面，ARM根本不是X86的对手。 

但ARM的优势不在于性能强大而在于效率，ARM采用RISC流水线指令集，在完成综合性工作方面根本就处于劣势，而在一些任务相对固定的应用场合其优势就能发挥得淋漓尽致。 



二、扩展能力 

X86结构的电脑采用“桥”的方式与扩展设备（如：硬盘、内存等）进行连接，而且x86结构的电脑出现了近30年，其配套扩展的设备种类多、价格也比较便宜，所以x86结构的电脑能很容易进行性能扩展，如增加内存、硬盘等。 

ARM结构的电脑是通过专用的数据接口使CPU与数据存储设备进行连接，所以ARM的存储、内存等性能扩展难以进行（一般在产品设计时已经定好其内存及数据存储的容量），所以采用ARM结构的系统，一般不考虑扩展。基本奉行“够用就好”的原则。 


三、操作系统的兼容性 


X86系统由微软及Intel构建的Wintel联盟一统天下，垄断了个人电脑操作系统近30年，形成巨大的用户群，也深深固化了众多用户的使用习惯，同时x86系统在硬件和软件开发方面已经形成统一的标准，几乎所有x86硬件平台都可以直接使用微软的视窗系统及现在流行的几乎所有工具软件，所以x86系统在兼容性方面具有无可比拟的优势。 

ARM系统几乎都采用Linux操作系统，而且几乎所有的硬件系统都要单独构建自己的系统，与其他系统不能兼容，这也导致其应用软件不能方便移植，这一点一直严重制约了ARM系统的发展和应用。GOOGLE开发了开放式的Android系统后，统一了ARM结构电脑的操作系统，使新推出基于ARM结构的电脑系统有了统一的、开放式的、免费的操作系统，为ARM的发展提供了强大的支持和动力。 


四、软件开发的方便性及可使用工具的多样性 

X86结构的系统推出已经近30年，在此期间，x86电脑经过飞速发展的黄金时期，用户的应用、软件配套、软件开发工具的配套及兼容等工作，已经到达非常成熟甚至可以说是完美的境界。所以使用X86电脑系统不仅有大量的第三方软件可供选择，也有大量的软件编程工具可以帮助您完成您所希望完成的工作。 

ARM结构的电脑系统因为硬件性能的制约、操作系统的精简、以及系统兼容等问题的制约，造成ARM结构的电脑系统不可能像X86电脑系统那样有众多的编程工具和第三方软件可供选择及使用，ARM的编程语言大多采用C和JAVA。 

对这一点的比较，更直接的结论是：基于x86结构电脑系统平台开发软件比ARM结构系统更容易、更简单、实际成本也更低，同时更容易找到第三方软件（免去自己开发的时间和成本），而且软件移植更容易。 



 

从以上对比分析，给了我们的一个很清晰的感觉，ARM和X86结构的电脑根本无法对比，ARM根本就不是X86电脑的的对手。是的，如果只考虑上述几个方面的要数，ARM确实无法与X86电脑竞争，甚至连比较的资格都没有。但是近1、2年，ARM的产品在终端应用特别是手持终端应用飞速发展（如：智能手机、平板电脑等），其销售数量已经远远超出x86结构的电脑销售数量，可见ARM是具有其与X86结构电脑不可对比的优势。该优势就是：功耗.


五、功耗 

X86电脑因考虑要适应各种应用的需求，其发展思路是：性能 + 速度。20多年来x86电脑的速度从原来8088的几M发展到现在随便就是几G，而且还是几核，其速度和性能已经提升了千、万倍，技术进步使x86电脑成为大众生活中不可缺少的一部分。但是x86电脑发展的方向和模式，使其功耗一直居高不下，一台电脑随便就是几百瓦，即使是号称低功耗节能的手提电脑或上网本，也有十几、二十多瓦的功耗，这与ARM结构的电脑无法相比。 

ARM的设计及发展思路是：满足某个特殊方面的应用即可，在某一专项领域是最强的，（哪怕在其他方面一无是处），这样ARM以其不是最强的技术，同样也不是很高级制程的制造工艺，生产出性能不是很强的电脑系统，但在某个专业应用方面则是最好的，特别是在众多终端应用，尤其在移动终端应用上占有绝对优势的统治地位，这个原因就是：功耗。 

高功耗导致了一系列X86系统无法解决的问题出现：系统的续航能力弱、体积无法缩小、稳定性差、对使用环境要求高等问题。从这里我们可以看到X86系统与ARM系统是在两个完全不同领域方面的应用，他们之间根本不存在替换性，在服务器、工作站以及其他高性能运算等应用方面，可以不考虑功耗和使用环境等条件时，X86系统占了绝对优势；

 

但受功耗、环境等条件制约且工作任务固定的情况下ARM占有很大的优势，在手持式移动终端领域，X86的功耗更使他英雄毫无用武之地。 

但在很多的应用终端领域，现正成为两大阵营争夺的重点，ARM阵营努力增加其性能和系统（特别是操作系统）的通用性，蚕食x86系统的部分终端应用市场；X86阵营努力降低功耗保住其市场，同时侵入手持移动终端市场。 

我们今天讨论的重点就是在两大阵营都能可以覆盖的终端应用领域进行对比、分析。这类型的应用一定是终端应用，通常有下面几个特征： 

1、系统的工作性质比较固定（如：POS、ATM、车载电脑系统、多媒体广告播放系统、视频监控系统，以及众多的信息接收、控制系统和专业的工控系统等等）； 

2、应用环境比较恶劣，如：温度变化很大，高温超过40度，低温达零下20度；多尘、潮湿等； 

3、有一定的应用数量，但数量不是很大。 

这部分的应用领域传统上是由X86结构的低功耗工控机（系统）实现的，但近几年ARM系统的飞速发展，特别是Android操作系统出现后，ARM + Android大有取代x86系统占领（低功耗）终端应用领域的趋势。我们在考虑这种应用对比时根据ARM和X86的特性，主要还考虑以下因素： 

1、性能： 

如果ARM系统的性能能满足应用需求时，建议尽可能采用ARM结构的产品，否则考虑X86的产品。注意在这里我们要强调的是：不要将两个系统的绝对性能进行比较，而是以能否您的应用特点为标准进行分析。 

2、应用数量： 

如果您的应用数量太少，您可能根本不值得独立开发一套应用系统，但如果您的应用数量达到几百甚至过千时，您是值得考虑自己开发一套新的系统的。因为：ARM的开发成本和制造成本相对比较低，如果有几百个以上终端应用，应该可以分摊掉开发成本。 

如果选用X86结构的系统，根本不应该考虑单独开发一套专用系统（因为开发成本太高，可能是ARM的10倍），而是在市场上筛选出最接近您需求的产品，以避免高昂的硬件开发成本，和今后的制造成本。

3、操作系统 

ARM的操作系统通常是单独建立一个自己的Linux系统，且系统与系统间不能兼容，这严重制约了ARM的应用扩展，但Android出现后，系统兼容的屏障正逐步消失，促进了系统以及应用软件的兼容，大大扩大了ARM应用软件的的数量同时扩大了其应用空间。 

4、功耗以及功耗延伸的系列问题

![img](G:\新知识\linux\images\840517-20180909003601148-1871432726.png)

 


ARM的优势是功耗低，其实低功耗还意味着： 

1）稳定性高：因为功耗越高电子元器件的稳定性和可靠性越差，对低功耗的产品只要选择好外围元件的品质，系统的稳定性不会有太大问题； 

2）散热成本低和可以考虑更小的产品体积：对高功耗的产品不可避免要考虑散热问题，而散热设备（或器件）的存在，有制约了产品的体积，对某些场合的应用构成致命的制约。但ARM的功耗 < 1W，完全不用考虑散热问题。 

3）功耗低对供电电源的要求低：几乎所有电子产品，（在同等条件下）功耗越高对电源的要求越高，电源的成本就越高。 

4）功耗低电池的续航时间长。

5）功耗低对抗环境伤害的能力强：低功耗产品因为不用考虑散热，可以将产品密封保护起来，但高功耗产品必须散热，甚至需要风扇帮助散热，这样必然使很多的元件和线路裸露在空气中，被空气中的尘埃、湿气、酸碱物质等腐蚀。 

5、软件开发成本问题 

ARM的操作系统很小（精简）不可能带很多工具，通常基于ARM的软件大多用C或JAVA开发，其成本会比基于X86系统的高。而且对大多数ARM而言，因其操作系统不一样，软件业不能在两个系统中自由互换使用，但一般来说：用C或JAVA编写的软件只需在ARM平台的操作系统中编译一下就可以移植过去。 

但对Android系统开发的软件，只要能在某台ARM设备中运行，就可以在另一台基于同样系统的设备中运行。 

6、硬件的开发成本 

ARM实际上在CPU芯片中已经整合了几乎所有功能，几乎所有线路按原理图直接拉出就可以了，需要扩展的部分一般不多，所以其开发成本会比较低，通常三五万就可以了。 

但X86的外围线路很多，需要相当经验的工程师，而且还有BIOS等设计，所以X86主板的设计费用会比较高，通常要二三十万。 

7、硬件的制造及应用成本 

无论ARM或X86主板其制造成本都是由元件和加工费构成，通常一片ARM的主板价格与一片X86主板的价格差不多，但ARM是一片可以独立使用的产品，x86主板通常还要加上：CPU、内存、硬盘甚至还有显卡。 

另外X86还要配上一个电源，这个电源比ARM的电源要贵很多。 

所以：明显X86在硬件方面的成本比ARM高得多。 

总结上面对比，X86系统和ARM系统应该是两个完全不同领域的应用，如果功能单一又受到环境制约的应用，如：POS、ATM、多媒体广告机（现已经有ARM+DSP的产品）、车载电脑终端等应用，应该首先考虑ARM方案，ARM方案与X86相比，其功耗和成本占有很大优势。

 

## 处理器适配架构（x86_64、armv7、armv7s、arm64、i386）

模拟器32位（即Mac处理器的指令集）：i386

模拟器64位（即Mac处理器的指令集）：x86_64

真机32位（即ARM处理器的指令集）：armv7、armv7s

真机64位（即ARM处理器的指令集）：arm64


项目开发中，可能使用第三方提供的静态库.a文件，或framework文件，如果静态库提供方技术不成熟，使用的时候就会出现问题，例如：

要解决以上问题，就要了解一下Apple移动设备处理器指令集相关的一些细节知识。

ARM处理器，特点是体积小、低功耗、低成本、高性能，所以几乎所有手机处理器都基于ARM，在嵌入式系统中应用广泛。

armv6、armv7、armv7s、arm64都是ARM处理器的指令集，这些指令集都是向下兼容的，如armv7指令集兼容armv6，只是使用armv6的时候无法发挥出其性能，无法使用armv7的新特性，从而会导致程序执行效率没那么高。
i386、x86_64都是Mac处理器的指令集。i386是针对intel通用微处理器32架构的。x86_64是针对x86架构的64位处理器。所以当使用iOS模拟器的时候会遇到i386、x86_64，iOS模拟器没有arm指令集。

目前iOS移动设备指令集
arm64：iPhone5S、iPad Air、iPad mini2(iPad mini with Retina Display)
armv7s：iPhone5、iPhone5C、iPad4(iPad with Retina Display)
armv7：iPhone3GS、iPhone4、iPhone4S、iPad、iPad2、iPad3(The New iPad)、iPad mini、iPod Touch 3G、iPod Touch4
armv6：iPhone、iPhone2、iPhone3G、第一代、第二代 iPod Touch（一般不需要去支持）

Xcode中指令集相关选项（Build Setting中）


（1）Architectures
Space-separated list of identifiers. Specifies the architectures (ABIs, processor models) to which the binary is targeted. When this build setting specifies more than one architecture, the generated binary may contain object code for each of the specified architectures. 
指定工程被编译成可支持哪些指令集类型，而支持的指令集越多，就会编译出包含多个指令集代码的数据包，对应生成二进制包就越大，也就是ipa包会变大。

（2）Valid Architectures
Space-separated list of identifiers. Specifies the architectures for which the binary may be built. During the build, this list is intersected with the value of ARCHS build setting; the resulting list specifies the architectures the binary can run on. If the resulting architecture list is empty, the target generates no binary. 
限制可能被支持的指令集的范围，也就是Xcode编译出来的二进制包类型最终从这些类型产生，而编译出哪种指令集的包，将由Architectures与Valid Architectures（因此这个不能为空）的交集来确定。
比如，Valid Architectures设置的支持arm指令集版本有：armv7、armv7s、arm64，对应的Architectures设置的支持arm指令集版本有：armv7s，这时Xcode只会生成一个armv7s指令集的二进制包。
再比如：将Architectures支持arm指令集设置为：armv7、armv7s，对应的Valid Architectures的支持的指令集设置为：armv7s、arm64，那么此时，XCode生成二进制包所支持的指令集只有armv7s。

在Xcode里的Valid Architectures设置里，默认为 Standard architectures(armv7,arm64)，如想改的话，可以在other中进行修改。

特别说明：
使用 standard architectures (including 64-bit)(armv7,arm64) 参数，则打的包里面有32位、64位两份代码，在iPhone5s（ iPhone5s的cpu是64位的 ）下，会首选运行64位代码包， 其余的iPhone（ 其余iPhone都是32位的,iPhone5c也是32位 ），只能运行32位包，但是包含两种架构的代码包，只有运行在ios6，ios7系统上。 
这也就是说，这种打包方式，对手机几乎没要求，但是对系统有要求，即ios6以上。 
而使用 standard architectures (armv7,armv7s) 参数， 则打的包里只有32位代码， iPhone5s的cpu是64位，但是可以兼容32位代码，即可以运行32位代码。但是这会降低iPhone5s的性能。 其余的iPhone对32位代码包更没问题， 而32位代码包，对系统也几乎也没什么限制。 
因此，要发挥iPhone5s的64位性能，就要包含64位包，那么系统最低要求为ios6。 如果要兼容ios5以及更低的系统，只能打32位的包，系统都能通用，但是会丧失iPhone5s的性能。

（3）Build Active Architecture Only
指定是否只对当前连接设备所支持的指令集编译
当其值设置为YES，这个属性设置为YES，是为了debug的时候编译速度更快，它只编译当前的architecture版本，而设置为NO时，会编译所有的版本。 编译出的版本是向下兼容的，连接的设备的指令集匹配是由高到低（arm64 > armv7s > armv7）依次匹配的。比如你设置此值为YES，用iphone4编译出来的是armv7版本的，iphone5也可以运行，但是armv6的设备就不能运行。所以，一般debug的时候可以选择设置为YES，release的时候要改为NO，以适应不同设备。 
（a）
Architectures: armv7、armv7s、arm64
Valid Architectures: armv6、armv7s、arm64
生成二进制包支持的指令集：arm64
（b）
Architectures: armv6、armv7、armv7s
Valid Architectures：armv6、armv7s、arm64
生成二进制包支持的指令集：armv7s 
（c）
Architectures: armv7、armv7s、arm64
Valid Architectures: armv7、armv7s
这种情况是报错的，因为允许使用指令集中没有arm64。

注：如果你对ipa安装包大小有要求，可以减少安装包的指令集的数量，这样就可以尽可能的减少包的大小。当然这样做会使部分设备出现性能损失，当然在普通应用中这点体现几乎感觉不到，至少不会威胁到用户体检。

使用场景，用户制作静态库.a文件，或framework文件时，对于指令集选择处理
如何制作一个“没有问题”的.a静态库，或framework，通过以上信息了解到，当我们做App的时候，为了追求高效率，并且减小包的大小，Build Active Architecture Only设置成YES，Architectures按Xcode默认配置就可以，因为arm64向前兼容。但制作.a静态库，或framework就不同了，因为要保证兼容性，包括不同iOS设备以及模拟器运行不出错，所以结合当前行业情况，要做到最大的兼容性。

正确的设置指令集类型如下所示：
Valid Architectures设置为：armv7、armv7s、arm64、i386、x86_64 
Architectures设置不变（或根据你需要）:  armv7、arm64

然后分别选择iOS设备和模拟器进行编译，最后找到相关的.a文件，或framework中的对应文件进行合包。

在终端使用命令：lipo -create 真机库.a的路径 模拟器库.a的的路径 －output 合成库的名字.a；或lipo -create 真机库framework中的文件的路径 模拟器库framework中的文件的路径 －output 合成库的名字；这样就制作了一个通用的静态库.a，或framework。

当然还可以查看静态库.a，或framework所支持的指令集。

在终端使用命令：lips -info 静态库.a文件；或lips -info framework中的文件。
