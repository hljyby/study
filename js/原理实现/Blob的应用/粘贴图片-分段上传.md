# [js中关于Blob对象的介绍与使用](https://www.cnblogs.com/wangfajing/p/7202139.html)

# blob对象介绍

一个 Blob对象表示一个不可变的, 原始数据的类似文件对象。Blob表示的数据不一定是一个JavaScript原生格式 blob对象本质上是js中的一个对象，里面可以储存大量的二进制编码格式的数据。

------

## 创建blob对象

创建blob对象本质上和创建一个其他对象的方式是一样的，都是使用Blob() 的构造函数来进行创建。 构造函数接受两个参数：

第一个参数为一个数据序列，可以是任意格式的值。

第二个参数是一个包含两个属性的对象{ type: MIME的类型, endings: 决定第一个参数的数据格式，可以取值为 "transparent" 或者 "native"（transparent的话不变，是默认值，native 的话按操作系统转换） 。 }

Blob()构造函数允许使用其他对象创建一个Blob对象，比如用字符串构建一个blob

```
var debug = {hello: "world"};
var blob = new Blob([JSON.stringify(debug, null, 2)],
  {type : 'application/json'});
```

既然是对象，那么blob也拥有自己的属性以及方法

#### 属性

- Blob.isClosed (只读)

  布尔值，指示 Blob.close() 是否在该对象上调用过。 关闭的 blob 对象不可读。

- Blob.size (只读)

  Blob 对象中所包含数据的大小（字节）。

- Blob.type (只读)

  一个字符串，表明该Blob对象所包含数据的MIME类型。如果类型未知，则该值为空字符串。

#### 方法

- Blob.close()

  关闭 Blob 对象，以便能释放底层资源。

- Blob.slice([start[, end[, contentType]]])

  返回一个新的 Blob 对象，包含了源 Blob 对象中指定范围内的数据。其实就是对这个blob中的数据进行切割，我们在对文件进行分片上传的时候需要使用到这个方法。

看到上面这些方法和属性，使用过HTML5提供的File接口的应该都很熟悉，这些属性和方法在File接口中也都有。 其实File接口就是基于Blob，继承blob功能并将其扩展为支持用户系统上的文件，也就是说：

File接口中的Flie对象就是继承与Blob对象。

# blob对象的使用

上面说了很多关于Blob对象的一些概念性的东西，下面我们来看看实际用途。

------

## 分片上传

> 首先说说分片上传，我们在进行文件上传的时候，因为服务器的限制，会限制每一次上传到服务器的文件大小不会很大，这个时候我们就需要把一个需要上传的文件进行切割，然后分别进行上传到服务器。

假如需要做到这一步，我们需要解决两个问题:

- 怎么切割?
- 怎么得知当前传输的进度?

首先怎么切割的问题上面已经有过说明，因为File文件对象是继承与Blob对象的，因此File文件对象也拥有slice这个方法，我们可以使用这个方法将任何一个File文件进行切割。

代码如下：

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```javascript
var BYTES_PER_CHUNK = 1024 * 1024; // 每个文件切片大小定为1MB .
var blob = document.getElementById("file").files[0];
var slices = Math.ceil(blob.size / BYTES_PER_CHUNK);
var blobs = [];
slices.forEach(function(item, index) {
    blobs.push(blob.slice(index,index + 1));
});
// 看他的思路，这代码不对
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

通过上面的方法。我们就得到了一个切割之后的File对象组成的数组blobs；

接下来要做的时候就是讲这些文件分别上传到服务器。

在HTTP1.1以上的协议中，有Transfer-Encoding这个编码协议，用以和服务器通信，来得知当前分片传递的文件进程。

这样解决了这两个问题，我们不仅可以对文件进行分片上传，并且能够得到文件上传的进度。

## 粘贴图片

> blob还有一个应用场景，就是获取剪切板上的数据来进行粘贴的操作。例如通过QQ截图后，需要在网页上进行粘贴操作。

粘贴图片我们需要解决下面几个问题

1. 监听用户的粘贴操作
2. 获取到剪切板上的数据
3. 将获取到的数据渲染到网页中

首先我们可以通过paste事件来监听用户的粘贴操作:

```javascript
document.addEventListener('paste', function (e) {
    console.info(e);
});
```

然后通过事件对象中的clipboardData 对象来获取图片的文件数据。

### clipboardData对象介绍

介绍一下 clipboardData 对象，它实际上是一个 DataTransfer 类型的对象， DataTransfer 是拖动产生的一个对象，但实际上粘贴事件也是它。

#### clipboardData 的属性介绍

| 属性          | 类型                 | 说明                                        |
| ------------- | -------------------- | ------------------------------------------- |
| dropEffect    | String               | 默认是 none                                 |
| effectAllowed | String               | 默认是 uninitialized                        |
| files         | FileList             | 粘贴操作为空List                            |
| items         | DataTransferItemList | 剪切板中的各项数据                          |
| types         | Array                | 剪切板中的数据类型 该属性在Safari下比较混乱 |

### items 介绍

items 是一个 DataTransferItemList 对象，自然里面都是 DataTransferItem 类型的数据了。

#### 属性

items 的 DataTransferItem 有两个属性 kind 和 type

| 属性 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| kind | 一般为 string 或者 file                                      |
| type | 具体的数据类型，例如具体是哪种类型字符串或者哪种类型的文件，即 MIME-Type |

#### 方法

| 方法        | 参数          | 说明                                              |
| ----------- | ------------- | ------------------------------------------------- |
| getAsFile   | 空            | 如果 kind 是 file ，可以用该方法获取到文件        |
| getAsString | function(str) | 如果 kind 是 string ，可以用该方法获取到字符串str |

在原型上还有一些其他方法，不过在处理剪切板操作的时候一般用不到了。

#### type 介绍

一般 types 中常见的值有 text/plain 、 text/html 、 Files 。

| 值         | 说明                     |
| ---------- | ------------------------ |
| text/plain | 普通字符串               |
| text/html  | 带有样式的html           |
| Files      | 文件(例如剪切板中的数据) |

有了上面这些方法，我们可以解决第二个问题即获取到剪切板上的数据。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```javascript
document.addEventListener('paste', function (e) {
    console.info(e);
    var cbd = e.clipboardData;
    for(var i = 0; i < cbd.items.length; i++) {
        var item = cbd.items[i];
        console.info(item);
        if(item.kind == "file"){
            var blob = item.getAsFile();
            if (blob.size === 0) {
                return;
            }
            console.info(blob);
        }
    }
});
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

最后我们需要将获取到的数据渲染到网页上。

其实这个本质上就是一个类似于上传图片本地浏览的问题。我们可以直接通过HTML5的File接口将获取到的文件上传到服务器然后通过讲服务器返回的url地址来对图片进行渲染。也可以使用fileRender对象来进行图片本地浏览。

### fileRender对象简介

从Blob中读取内容的唯一方法是使用 FileReader。

FileReader接口有4个方法，其中3个用来读取文件，另一个用来中断读取。无论读取成功或失败，方法并不会返回读取结果，这一结果存储在result属性中。

| 方法名             | 参数            | 描述                   |
| ------------------ | --------------- | ---------------------- |
| readAsBinaryString | file            | 将文件读取为二进制编码 |
| readAsText         | file,[encoding] | 将文件读取为文本       |
| readAsDataURL      | file            | 将文件读取为DataURL    |
| abort              | (none)          | 终端读取操作           |

FileReader接口包含了一套完整的事件模型，用于捕获读取文件时的状态。

| 事件        | 描述                   |
| ----------- | ---------------------- |
| onabort     | 中断                   |
| onerror     | 出错                   |
| onloadstart | 开始                   |
| onprogress  | 正在读取               |
| onload      | 成功读取               |
| onloadend   | 读取完成，无论成功失败 |

通过上面的方法以及事件，我们可以发现，通过readAsDataURL方法及onload事件就可以拿到一个可本地浏览图片的DataURL。

最终代码如下：

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```javascript
document.addEventListener('paste', function (e) {
    console.info(e);
    var cbd = e.clipboardData;
        var fr = new FileReader();
        var html = '';
        for(var i = 0; i < cbd.items.length; i++) {
            var item = cbd.items[i];
            console.info(item);
            if(item.kind == "file"){
                var blob = item.getAsFile();
                if (blob.size === 0) {
                    return;
                }
                console.info(blob);
                fr.readAsDataURL(blob);
                fr.on<x>load=function(e){
                    var result=document.getElementById("result");
                    //显示文件
                    result.innerHTML='<img src="' + this.result +'" alt="" />';
                }
            }
        }
});
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

这样我们就可以监听到用户的粘贴操作，并且将用户粘贴的图片文件实时的渲染到网页之中了。

# 总结

以上是我对Blob对象的一些学习分享，希望在实际应用上能对大家有所帮助。

# BLOB详解

`BLOB`是`Binary Large Object`的缩写，意为“大的二进制对象”。

《JavaScript权威指南》中对BLOB的描述：

> A Blob is an opaque reference to, or handle for, a chunk of data.
> Blobs oten represent chunks of data from an external source such as a local file, a URL, or a database.

BLOB的两个特点：

- large: Blob表示巨大的数据块，如视频文件
- opaque(不透明): 我们对BLOB可以做到操作仅限于设置字节长度、获取MIME类型、截取更小的BLOB。



![Blob操作](https://imgedu.lagou.com/e8b8d2eab63d44639ba3700eb2776195.jpg)



## 获取Blob的方式:

### 1. Blob支持结构化克隆算法（structured clone algorithm），所以可以通过消息事件从另外一个窗口或线程中获取blob对象

### 2. 从客户端数据库取出blob

### 3. 通过http从网络上下载blob

```
function getBlob(url, callback){
    let xhr = new XMLHTTPRequest();
    xhr.open("GET", url);
    xhr.responseType = "blob";
    xhr.onload = function() {
        callback(xhr.response); // 注意，是 .response 而不是 .responseText 
    }
    // 如果下载的blob很大，可以使用 onprogress 获取下载进度
    xhr.send(null);
}
复制代码
```

### 4. 通过`BlobBuilder`创建新的blob对象

```
var bb = new BlobBuilder();
bb.append('this blob contains this text and 10 big-endian 32-bit signed ints.'); // 写入字符串
bb.append('\0'); // 写入空字符，表示字符串已结束
var arraybuffer = new ArrayBuffer(4*10);
var dataView = new DataView(arrayBuffer);
for(var i=0; i<10; i++){
    dataView.setInt32(i*4, i);
}
bb.append(arrayBuffer); // 写入ArrayBuffer
var blob = bb.getBlob('x-optional/mime-type-here'); // 获取blob，并指定mime类型
复制代码
```

### 5. 客户端JS中的`File`对象是BLob的子类型。File是一个有名称（name）和修改日期（lastModifiedDate）属性的Blob数据。可以通过``元素标签或者拖拽接口获取File对象。

```
<input type="file" id="ele">

const selectedFiles = document.getElementById("ele").files
// files属性是的值是一个File对象数组，包含用户选择的0个或多个文件的file对象。
for (let i = 0; i < selectedFiles.length; i++) {
    const f = selectedFiles[i]
    console.log(f.name, f.lastModifiedDate)
    console.log(f.size, f.type) // Blob对象的属性
}
复制代码
```

## 对Blob对象可做如下操作:

### 1. 创建Blob URL

Blob url 是指向存储在浏览器缓存或磁盘中的blob的一个引用。

通过`createObjectURL()`获取指向Blob数据的url `blob://`，并且在DOM、css中使用blob url，用法和普通的url一样。

Blob URL 受同源策略限制，只有在同源的document中是合法的。

Blob URL不是不变的，创建Blob URL的document被用户关闭后，Blob URL就会变成无效的。

```
blob://URL`工作方式和`http://URL`类似，当请求`blob://URL`时浏览器行为和http请求相同。如果请求的blob url不再合法，浏览器必须返回404（Not Found）状态码。当请求不同源的blob url时，浏览器必须返回403（Not Allowed）。 Blob URL 只允许通过 `GET` 请求，请求成功需要返回状态码200，并且`response.header.Content-Type = Blob.type
```

下面的代码是通过blob url预览拖拽到指定区域的图片文件。

```
<!DOCTYPE html>
<html>
    <head>
        <script>
            // 处理浏览器兼容问题
            var getBlobURL = (window.URL && URL.createObjectURL.bind(URL)) ||
                (window.webkitURL && webkitURL.createObjectURL.bind(URL)) ||
                window.createObjectURL;
            // 释放之前通过createObjectURL创建的对象
            var revokeBlobURL = (window.URL && URL.revokeObjectURL.bind(URL)) ||
                (window.webkitURL && webkitURL.revokeObjectURL.bind(URL)) ||
                window.revokeObjectURL;
            
            window.onload = function(){
                var droptarget = document.getElementById('droptarget');
                droptarget.ondragenter = function (e) {
                    var types = e.dataTransfer.types;
                    if (!types ||
                        (types.contains && types.contains('Files')) ||
                        (types.indexOf && types.indexOf('Files') !== -1)
                    ){
                        droptarget.classList.add('active');
                        return false;
                    }
                };
                
                droptarget.ondragleave = function () {
                    droptarget.classList.remove('active');
                };
                
                droptarget.ondragover = function(e) {
                    return false;
                };
                
                droptarget.ondrop = function(e) {
                    var files = e.dataTransfer.files;
                    for(var i=0; i<files.length; i++){
                        var type = files[i].type;
                        if (type.substring(0, 6) !== 'image/') {
                            continue;
                        }
                        var img = document.createElement('img');
                        img.src = getBlobURL(files[i]);
                        img.onload = function () {
                            this.width = 100;
                            document.body.append(this);
                            revokeBlobURL(this.src); // 防止内存泄漏
                        }
                    }
                    droptarget.classList.remove('active');
                    return false;
                }
            }
        </script>
        <style>
            #droptarget {border: solid black 2px; width: 200px; height: 200px;}
            #droptarget.active {border: solid red 4px;}
        </style>
    </head>
    <body>
    <div id="droptarget">Drop Files Here</div>
    </body>
</html>
复制代码
```

1. 通过`postMessage()`在窗口和工作进程间传输blob数据
2. 将blob存储在客户端数据库
3. 通过XMLHTTPRequest的`send()`方法将blob上传到服务器

### 5. `FileReader`对象的异步接口以`string`或`ArrayBuffer`的形式提取blob对象的内容。

因为Blob的体积比较大，所有访问磁盘上的blob的相关API都是异步的。

```
function readfile(f){
    var reader = new FileReader();
    reader.readAsText(f);
    reader.onload = function () {
        var text = reader.result;
        console.log('file content: ', text);
    }
    reader.onerror = function(e){
        console.log('Error', e);
    }
}
复制代码
```

1. 通过`Filesystem API`和`FileWriter`对象将Blob对象写到本地文件，相关接口浏览器暂不支持。

内容来源于网络，如有侵权请联系客服删除





# 区别 URL.createObjectURL() 和 FileReader.readAsDataURL()

![img](https://csdnimg.cn/release/blogv2/dist/pc/img/original.png)

[珍妮的小罐君](https://blog.csdn.net/qq_36671474) 2019-09-04 19:46:38 ![img](https://csdnimg.cn/release/blogv2/dist/pc/img/articleReadEyes.png) 1692 ![img](https://csdnimg.cn/release/blogv2/dist/pc/img/tobarCollect.png) 收藏 3

分类专栏： [Angular](https://blog.csdn.net/qq_36671474/category_6647683.html) 文章标签： [fileReader](https://www.csdn.net/gather_25/MtTaEg0sMzMyMDMtYmxvZwO0O0OO0O0O.html) [creatObjectURL](https://so.csdn.net/so/search/s.do?q=creatObjectURL&t=blog&o=vip&s=&l=&f=&viparticle=) [预览](https://www.csdn.net/gather_2c/MtTaEg0sMDExODgtYmxvZwO0O0OO0O0O.html)

版权

**业务场景：**

**图片上传和预览功能~

\**具体实现：\****

- **URL.createObjectURL()**

  ```
  URL.createObjectURL() 静态方法会创建一个 DOMString，其中包含一个表示参数中给出的对象的URL。这个 URL 的生命周期和创建它的窗口中的 document 绑定。这个新的URL 对象表示指定的 File 对象或 Blob 对象。
  ```

  简单说经过这个方法的处理后会生成一个临时的链接，然后直接赋值给src就行~

  使用方式：

  ```
  objectURL = URL.createObjectURL(blob);
  ```

  示例：

  ```
  <input #fileInput="grFileUploader" type="file" style="display: none"       (change)="fileChange(idx, fileInput.files)"       accept=".png,.jpeg,.jpg"> <img [src] ="imgsrc"/> imgsrc:string=""; fileChange(index: number, files?: FileList): void {    const file = files && files.item(0);     if (file) {       this. imgsrc= URL.createObjectURL(file)    }}
  ```

- **FileReader.readAsDataURL()**

  ```
  FileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。
  ```

  异步读取指定的

  Blob

  中的内容，一旦完成，会返回一个

  ```
  data:
  ```

   URL格式的字符串以表示所读取文件的内容。

  使用方式：

  ```
  fileStr = FileReader.readAsDataURL(blob)
  ```

  示例：（同上）

  - **区别

    （1）返回值

    **    FileReader.readAsDataURL(blob)可以得到一段base64的字符串
        URL.createObjectURL(blob)得到的是当前文件的一个内存url

    ***\*（2）内存使用\****

    ​     FileReader.readAsDataURL(blob)得到一段超长的base64的字符串
    ​     URL.createObjectURL(blob)得到的是一个url地址

    **（3）内存清理**

    ​     FileReader.readAsDataURL(blob)依照js垃圾回收机制自动从内存中清理
    ​     URL.createObjectURL(blob)存在于当前document内，清除方式只有upload()事件或者revokeObjectURL()手          动清除 

    **（4）执行方式**
         
         FileReader.readAsDataURL(blob)通过回调的方式f返回，异步执行；
         URL.createObjectURL(blob) 直接返回，同步执行；

    **（5）多个文件**
         
         FileReader.readAsDataURL(blob)同时处理多个文件时，需要一个文件对应一个FileReader对象；
         URL.createObjectURL(blob) 依次返回，没有影响；

- **总结**

- URL.createObjectURL(blob) 得到本地内存容器的`URL`地址，方便预览，多次使用需要注意手动释放内存的问题，性能优秀。
  FileReader.readAsDataURL(blob)胜在直接转为`base64`格式，可以直接用于业务，无需二次转换格式。

-  

- **附**

  ```
  Base64 to Blob function dataURLtoBlob(dataurl) {    var arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1],        bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);    while (n--) {        u8arr[n] = bstr.charCodeAt(n);    }    return new Blob([u8arr], { type: mime });}
  ```

   

  