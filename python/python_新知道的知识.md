## "->"   和   "... "  还有  ":"

- ### **->**

  - ```python
    def func() -> int:
        pass
    
    # -> 代表的意思是 返回值为int 类型
    ```

- ### **...** **Ellipsis** 省略号

  - ```python
    # 省略号代表省略 可替换 pass
    # Numpy的语法糖 数学处理 数学处理是什么自己查去我现在不用
    def func():	
        ...
       
    def func(a:int=...):
        print(a)
    ```

- ### **:** 冒号

  - ```python
    def func(a:int):
        pass
    # 冒号的意思是a的数据类型必须为int 类型
    ```





# \__str\__ 和 \__repr\__

- ```python
  def __str__(self):
      return '__str__'
  # 函数的作用是打印对象的时候按照__str__ 返回的东西打印
  
  def __repr__(self):
      return self.__str__()
  
  # __repr__ 函数是在打印列表里面包含对象时调用这个方法，和__str__类似
  ```

通过如上的例子可以看出，当直接查看对象的时候调用的是__repr__方法，对象需要转字符串的时候调用的是__str__方法，但是当字典列表等容器的时候调用的还是__repr__方法

如果我们需要显示的指定以何种方式进行类到字符串的转化，我们可以使用内置的 str() 或 repr() 方法，它们会调用类中对应的双下划线方法。除了字典、列表等作为容器的时候print(str(["d","f",t])),虽然调用的是str()方法，可是容器是列表，所以对象t转为字符串时调用的就是__repr__

**__str__ 和 __repr__ 的差别** 

那么他们的区别具体的在哪里，带着这个问题我们python的标准库， 其中datetime.date 这个类是怎么在使用这两个方法的。

```
import datetime
today = datetime.datetime.today()
print(str(today))
>>> 2019-10-20 20:59:47.003003
print(repr(today))
>>> datetime.datetime(2019, 10, 20, 20, 59, 47, 3003)
```

__str__ 的返回结果可读性强。也就是说，__str__ 的意义是得到便于人们阅读的信息，就像上面的 '2019-10-20 20:59:47.003003' 一样。

__repr__ 的返回结果应更准确。怎么说，__repr__ 存在的目的在于调试，便于开发者使用。将 __repr__ 返回的方式直接复制到命令行上，是可以直接执行的。

 **为什么每个类都最好有一个 __repr__ 方法**

如果你想保证每个类到字符串都有一个有效的自定义转换方式，你需要重写__str__或者__repr__中的一个方法，如果没有写__str__方法，python就会去找__repr__方法，所以至少添加一个

```
class T:
    def __repr__(self):
        return (self.color)
    def __init__(self,color):
        self.color = color
t = T("red")
print(t)
>>> redt>>> redprint(str(t))>>> red
```

 实现了 __repr__ 方法后，当我们查看类的实例或者直接调用 repr() 方法，就能得到一个比较满意的结果了。打印或直接调用str（）等类转字符串的操作都会得到相同的结果，因为**__str__的默认实现就是调用__repr__方法。**

这样就能用比较少的工作量，不用手动的去一一获取信息，就能让两个方法都能功能，而且都具有一定的可读性，所以推荐类中至少添加一个__repr__ 方法。

**小结**

- 我们可以使用__str__ 和 __repr__中的任意一个方法定义类到字符串的转化方式，不需要手动的打印某些属性和一些额外的信息
- 一般来说__str__的可读性更强，而__repr__的返回结果更具有准确性，更加的适合开发者
- 我们在写类的时候，最好至少添加一个__repr__方法，来保证类到字符串的转换具有自定义的有效性，__str__是可选的，因为在默认情况下，__Str__方法默认实现调用的是__repr__方法，所以在对象转字符串时候，找到底层str方法之后，会调用重写的__repr__方法

也就是说，

　　直接查看字符串的时候调用的是__repr__方法；

　　对象在转字符串的时候：如果容器是字典或者列表调用的是__repr__方法；如果是其他情况则默认调用的是底层的__Str__方法。__str__如果被重写调用的则是重写之后__Str__,就和__repr__没有关系了，如果没有被重写，则调用的是底层__str__方法，底层方法默认实现方式是调用了__repr__ 方法，之后查看__repr__是否被重写，重写则调用重写之后的，否则调用底层的__repr__,最后执行转为字符串

　　如果打印str(t)则默认调用的是__str__，如果直接打印repr(t)则默认调用的是__repr__方法